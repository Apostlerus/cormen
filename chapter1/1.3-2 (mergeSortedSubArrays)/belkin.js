/**
 * Не понял, что значит "напишите текст". Нужно ли описание ли программа?
 * Решил написать программу, что уж, логику проще в коде показать имхо
 */

/**
 * Попытался совсем без временных массивов.
 * Вышло только так - медленно, с O(n^2)
 * Хотя по сути как в учебнике. Во внутреннем цикле приходится сдвигать
 * элементы, т.к. нет какого-то временного массива, отсюда и n^2.
 */
function mergeSlow(A, p, q, r) {
  if (A[q] <= A[q + 1]) {
    return;
  }
  while (p <= q && q + 1 <= r) {
    if (A[p] <= A[q + 1]) {
      p++;
    } else {
      let value = A[q + 1];
      let index = q + 1;
      while (index !== p) {
        A[index] = A[index - 1];
        index--;
      }
      A[p] = value;
      p++;
      q++;
    }
  }
}

/**
 * С временным массивом получается уже O(n)
 * Все равно, конечно, визуально получается каша разных индексов.
 * Я бы в реале mergeSort пилил так, чтобы merge принимал два разных массива,
 * тогда бы не было всех индексов и функция была бы читаемая,
 * но мы же тут алгоритмы пилим:)
 */
function merge(A, start, mid, end) {
  let i, p = i = start, s = mid + 1, temp = [];
  if (A[mid] <= A[s]) {
    return;
  }
  while (i <= mid && s <= end) { // Пока одна из половин не кончилась,
    if (A[i] < A[s]) {           // Сравниваем крайние элементы, кладём во временный массив
      temp[p++] = A[i++];
    } else {
      temp[p++] = A[s++];
    }
  }
  while (i <= mid) {             // Докладываем оставшиеся элементы
    temp[p++] = A[i++];
  }
  for (let j = start; j <= end; j++) {
    A[j] = temp[j];              // Перемещаем элементы в исходный массив
  }
}

let A = [31, 41, 59, 65, 2, 14, 41, 58]; // Лист с двумя отсортированными половинами
merge(A, 0, 3, 7);
console.log(A);
