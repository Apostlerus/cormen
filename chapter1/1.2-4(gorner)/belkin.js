/**
 * Да уж, матеша зашла в класс)
 * Почитал про схему Горнера. Как я понимаю, задача предполагает,
 * что эта схема и есть более быстрое решение.
 * По схеме мы выносим x за скобки n-2 раз. Так можно одним
 * проходом с конца умножать x на коэффициент, прибавлять предыдущий
 * коэффициент, сумму умножать на x, прибавлять предыдущий коэффициент,
 * умножать на x, и т.д. пока в конце не прибавим a0 и это и будет
 * искомое значение, вычисление за O(n)
 */
function polynomial(multipliers, x) {
  const length = multipliers.length;
  let polynomial = x * multipliers[length - 1];
  for (let i = length - 2; i >= 1; i--) {
    polynomial = (polynomial + multipliers[i]) * x;
  }
  polynomial += multipliers[0];
  return polynomial;
}

const A = [3, 2, 4];
const x = 2;

console.log(polynomial(A, x));
// 3 + (2 * 2^1) + (4 * 2^2) = 3 + 2(2 + (4 * 2)) = 23
// Один проход, сложность O(n)

/**
 * Я так и не понял, какое именно естественное решение займет O(n^2).
 * Возможно, имеется в виду лобовое - брать каждый коэффициент
 * и умножать на соответствующую степень x.
 * Тогда, если мы представляем возведение в степень как
 * несколько простых операций умножения, то мы пройдём n раз по
 * массиву, и на последнем сделаем n-2 операций умножения.
 * Хотя количество операций будет не n^2, а что-то типа (n-1)^2 + n - 1
 * Но это всё равно значит что сложность запишется как O(n^2)
 * */
